---
id: new-graphql-api
title: New GraphQL API
sidebar_label: New GraphQL API
keywords: ["scaffolding", "new", "graphql", "api"]
description: Learn how to use the New GraphQL API scaffold.
---

import CenteredImage from "@components/CenteredImage";
import cloudInfrastructureDiagram from "./new-graphql-api/new_graphql_api_scaffold.png";

:::info Can I use this?

This feature is available since **v5.13.0**.

:::

:::tip What you'll learn

- main features of the **New GraphQL API** scaffold
- how to continue developing on top of the generated application code

:::

## Overview

The **New GraphQL API** scaffold creates a new standalone GraphQL HTTP API, which can be utilized by your frontend applications. Once created, you can start extending it either manually via the existing [`GraphQLSchemaPlugin`](https://github.com/webiny/webiny-js/blob/v5.11.0/packages/handler-graphql/src/plugins/GraphQLSchemaPlugin.ts#L10) plugins, or even the [Extend GraphQL API](/docs/how-to-guides/webiny-cli/scaffolding/extend-graphql-api) scaffold.

##
## Features

### Clean Setup

Except for the base application and cloud infrastructure code, the created GraphQL API does not contain any additional code or specific business logic. It's a *clean slate* and you can start building on top of the created code in any way you prefer. You can also bring needed libraries, introduce new cloud infrastructure resources, and more.

Be sure to check the [Development](/docs/how-to-guides/webiny-cli/scaffolding/new-graphql-api#development) section below to learn more.

### Simple Cloud Infrastructure

Only a couple of cloud infrastructure resources need to be deployed in order to host a new GraphQL API, which is depicted by the following diagram:

<CenteredImage shadow={false} alt="Cloud Infrastructure Resources" src={cloudInfrastructureDiagram} />

As shown, the scaffold will also include a single Amazon DynamoDB <diagram-letter>D</diagram-letter> table, which you can use for all of your GraphQL API's data storing and retrieval needs. In case you need additional databases, you're free to include them (more on this in the [Development](/docs/how-to-guides/webiny-cli/scaffolding/new-graphql-api#development) section below).

Additionally, note that when [deploying](/docs/how-to-guides/deployment/deploy-your-project) into the production (`prod`) environment, the GraphQL Handler AWS Lambda <diagram-letter>C</diagram-letter> function will be deployed into a new [Amazon Virtual Private Cloud (VPC)](https://aws.amazon.com/vpc/). Down the line, doing this for cloud infrastructure resources can improve your GraphQL API's overall security posture.

### Compatible With the Existing Extend GraphQL API Scaffold

In order to speed up development, you can use the existing [Extend GraphQL API](/docs/how-to-guides/webiny-cli/scaffolding/extend-graphql-api) scaffold to quickly extend the created GraphQL API with new sets of essential CRUD GraphQL query and mutation operations.

In fact, during the **New GraphQL API** scaffold's setup wizard, users will be asked if they want to immediately do that.

### Testing Ready

Except for the application and cloud infrastructure code, the scaffold also generates the necessary [Jest](/docs/key-topics/tools-libraries#testing) configuration and foundation for testing the GraphQL API functionality you'll be building.

## Development

### Essential Files

The following are the most essential files and folders that are generated in the scaffolding process.

[`pulumi/`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi)

This is the folder that contains all of the cloud infrastructure code. In it, we have the [`dev`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi/dev) and [`prod`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi/dev) folders, which represent the cloud infrastructure resources that will be deployed into development and production environments, respectively.

If we were to compare the two, we'd find that the code located in the `prod` folder also deploys a new [Amazon Virtual Private Cloud (VPC)](https://aws.amazon.com/vpc/) and that the single AWS Lambda function is deployed into it. Down the line, doing this for cloud infrastructure resources can improve our GraphQL API's overall security posture.

Note that, by default, the code in the `prod` folder will only be used when deploying into the `prod` environment. If you wish to also use this

### First Deploy

Once you've completed the scaffold's wizard and the files have been generated, in order to actually see the changes made to your GraphQL API, you need to deploy them. This can be done as usual via the [`webiny deploy`](/docs/how-to-guides/deployment/deploy-your-project) command, or, even easier, if you're about to jump straight into coding, by running the [`webiny watch`](/docs/how-to-guides/webiny-cli/use-watch-command) command. This command will not only deploy the changes, but also start a new watch session, which will automatically redeploy further application code changes, as you perform them. More on this below.

### Development Using the Watch Command

The most straightforward way to further develop on top of the generated code would be via the [`webiny watch`](/docs/how-to-guides/webiny-cli/use-watch-command) command.

In order to get started, from your project root, simply run the following command:

```
yarn webiny watch api/code/graphql --env {env}
```

With the new watch session initialized, every change you make in the code will automatically trigger a re-deploy of the code, enabling you to see the changes in the cloud almost immediately as you make them (every redeployment takes 2-4 seconds to complete).

And although developers often choose this approach when developing smaller features or proof of concepts, for anything larger in scope, we recommend the new code to be tested via one or more of the mentioned types of tests.

### Writing and Running Tests

As mentioned in the [Features](/docs/how-to-guides/webiny-cli/scaffolding/extend-graphql-api#features) section, by default, the scaffold includes three tests: one unit, one integration, and one end-to-end (E2E) test. When generated, all three tests should be passing once you run them, but do note that in order for the integration and end-to-end (E2E) tests to pass, you have to have your **API** project application already deployed, preferably into a development environment, for example `dev`.

:::info
To run the tests, Webiny relies on [Jest](/docs/key-topics/tools-libraries#testing), a JavaScript testing framework with a focus on simplicity.
:::

#### Initial Test Files

#### [`typeDefs.unit.test.ts`](https://github.com/webiny/webiny-js/blob/v5/packages/cli-plugin-scaffold-graphql-service/template/__tests__/typeDefs.unit.test.ts)

A simple unit test which simply ensures that the base GraphQL type exists. Might not be a super useful example, but still, this test is here more for awareness purposes (so that developers know these can be added too).

#### [`crud.integration.test.ts`](https://github.com/webiny/webiny-js/blob/v5/packages/cli-plugin-scaffold-graphql-service/template/__tests__/crud.integration.test.ts)

An integration test which ensures essential CRUD GraphQL query and mutation operations are working as expected. These tests are run against the application code that you have locally, but note that the code is still interacting with real cloud infrastructure resources.

#### [`crud.e2e.test.ts`](https://github.com/webiny/webiny-js/blob/v5/packages/cli-plugin-scaffold-graphql-service/template/__tests__/crud.e2e.test.ts)

An end-to-end (E2E) test which ensures essential CRUD GraphQL query and mutation operations are working as expected.

Note that, although it may seem this test is testing the same functionality we've tested with the integration test, this test is run against the application code that's deployed into the actual cloud, by issuing HTTP requests to the deployed Cloudfront distribution, behind which our AWS Lambda function resides. In other words, this test makes sure not only our code is working as expected, but also that the cloud infrastructure resources are deployed and configured properly.

#### Running Tests

All of the test-running scripts can already be found in your root [package.json](https://github.com/webiny/webiny-js/blob/next/packages/cwp-template-aws/template/dependencies.json#L68-L71) file.

In order to run all tests, use the `yarn test` command. Additionally, to only run tests of a specific type, use the `yarn test:unit`, `yarn test:integration`, and `yarn test:e2e` commands.

:::tip
Jest supports the [`--watch`](https://jestjs.io/docs/cli#--watch) argument, which enables us to continuously re-run tests as we're making changes to them. You can use it with the above-shown commands.
:::

#### Creating New Tests

You are free to create new tests in the similar fashion, or amend the existing one.

## FAQ

#### How does security (authentication and authorization) work?

Please note that, by default, the authentication and authorization logic isn't included in the generated code. In other words, all of the generated GraphQL query and mutation operations can be performed by anonymous (not logged-in) users, which is in most cases not the desired behaviour.

Luckily, with a couple of built-in utilities, this can be relatively easily added. Please check out the [existing tutorials](/docs/tutorials/extend-admin-area/security/introduction) to learn how to implement these on your own.

#### Do I need to deploy the created GraphQL API in order to continue development?
