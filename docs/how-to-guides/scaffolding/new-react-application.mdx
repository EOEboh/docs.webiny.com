---
id: new-react-application
title: New React Application
sidebar_label: New React Application
keywords: ["scaffolding", "new", "react", "application"]
description: Learn how to use the New React Application scaffold.
---

import CenteredImage from "@components/CenteredImage";
import cloudInfrastructureDiagram from "./new-react-application/new_react_app_scaffold.png";
import preview from "./new-react-application/preview.png";

:::info Can I use this?

This feature is available since **v5.13.0**.

:::

:::tip What you'll learn

- main features of the **New React Application** scaffold
- how to continue developing on top of the generated application code

:::

## Overview

As the name suggests, the **New React Application** scaffold creates a new standalone React application. It consists of a couple of simple pages and examples which makes it possible to quickly get started with building a new frontend application.

<CenteredImage shadow={false} canEnlarge={false} alt="The New React Application" src={preview} />

## Features

### Clean Setup

Except for the provided example pages, base application, and cloud infrastructure code, the created React application does not contain any additional code or specific business logic. It's a _clean slate_ and you can start building on top of the created code in any way you prefer. You can also bring needed libraries, introduce new cloud infrastructure resources, and more.

Be sure to check the [Development](/docs/how-to-guides/webiny-cli/scaffolding/new-graphql-api#development) section below to learn more.

### Simple Page Example

### Simple Cloud Infrastructure

Only a couple of cloud infrastructure resources need to be deployed in order to host a new GraphQL API, which is depicted by the following diagram:

<CenteredImage
  shadow={false}
  canEnlarge={false}
  alt="Cloud Infrastructure Resources"
  src={cloudInfrastructureDiagram}
/>

:::info
The shown cloud infrastructure resources do not need to be deployed immediately after the scaffolding process has been completed. Frontend application development can still be performed locally, on developer's machine. But, once it's time to deploy it, you can do that as usual, with the [`webiny deploy`](/docs/how-to-guides/deployment/deploy-your-project) command.
:::

## Development

### Essential Files and Folders

The following are the most essential files and folders that are generated during the scaffolding process.

```bash title="New React Application Folder (Some Files Removed for Brevity)"
├── code
│   ├── public                    # Contains initial HTML file and meta files.
│   ├── src                       # React application code.
│   │   ├── components            # Shared components go here.
│   │   ├── images                # Images go here.
│   │   ├── plugins               # All plugins go here.
│   │   ├── styles                # All SCSS styles go here.
│   │   ├── App.scss              # SCSS styles entrypoint file.
│   │   ├── App.tsx               # Contains root `App` React component.
│   │   ├── apollo.ts             # Sets up the Apollo GraphQL client.
│   │   └── index.tsx             # Application entrypoint file.
│   ├── package.json              # Package's manifest file.
│   ├── tsconfig.json             # TypeScript config file.
│   └── webiny.config.ts          # Webiny config file (contains build scripts).
├── pulumi                        # Cloud infrastructure code.
│   ├── app.ts
│   ├── cloudfront.ts
│   └── index.ts                  # Cloud infrastructure code entrypoint file.
├── Pulumi.yaml                   # Pulumi project file.
├── tsconfig.json                 # TypeScript configuration used with the Pulumi cloud infrastructure code.
└── webiny.application.ts         # Project application's manifest file.
```

:::info
The path in which the new GraphQL API and all of its files and folders are created is specified in the scaffold's wizard.
:::

#### [`code/src/`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/code/graphql/src)

Contains the GraphQL API application code. This is where you'll be defining the GraphQL schema, resolver functions, business logic, authentication / authorization logic, writing tests, and potentially more.

#### [`code/graphql/src/types.ts`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/code/graphql/src/types.ts)

Contains global type definitions, that can be imported in different places in your application code.

When created, it only exports the [`Context`](https://github.com/webiny/webiny-js/blob/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/code/graphql/src/types.ts#L9) interface, which defines the `context` object that you will often be using while creating GraphQL resolver functions. If you will be extending the `context` object, for example via custom [`ContextPlugin`](https://github.com/webiny/webiny-js/blob/cli-scaffold-react-app/packages/handler/src/plugins/ContextPlugin.ts#L7) plugins, an update to this interface should be made as well. By doing this, you and your team will benefit from improved type-safety and easier discovery process.

#### [`code/graphql/src/plugins`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/code/graphql/src/plugins)

This is where you'll be creating plugins, either manually or via other scaffolding utilities, for example via the [Extend GraphQL API](/docs/how-to-guides/webiny-cli/scaffolding/extend-graphql-api) scaffold.

:::tip
Do have in mind that every plugin (or a collection of plugins) you create also needs be imported and registered in the [`code/graphql/src/index.ts`](https://github.com/webiny/webiny-js/blob/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/code/graphql/src/index.ts#L11) entrypoint file.
:::

#### [`code/graphql/jest.config.js`](https://github.com/webiny/webiny-js/blob/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/code/graphql/jest.config.js)

The config for the [Jest](/docs/key-topics/tools-libraries#testing) testing framework. Feel free to adjust it to your needs.

#### [`code/graphql/.babelrc.js`](https://github.com/webiny/webiny-js/blob/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/code/graphql/.babelrc.js)

The config for the [Babel](/docs/key-topics/tools-libraries#building-code) JavaScript compiler. Feel free to adjust it to your needs.

#### [`code/graphql/package.json`](https://github.com/webiny/webiny-js/blob/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/code/graphql/package.json)

In case you missed it, every Webiny project is organized as a monorepo, which can consist of multiple packages. This is the reason why the [`package.json`](https://github.com/webiny/webiny-js/blob/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/code/graphql/package.json) manifest file exists.

In most cases, this file will only be modified when new NPM packages are added.

:::info
Learn more about the monorepo organization in the [Monorepo Organization](/docs/key-topics/project-organization/monorepo-organization) key topic.
:::

#### [`pulumi/`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi)

This is the folder that contains all of the cloud infrastructure code. In it, we have the [`dev`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi/dev) and [`prod`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi/prod) folders, which represent the cloud infrastructure resources that will be deployed into development and production environments, respectively.

If we were to compare the two, we'd find that the code located in the [`prod`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi/prod) folder also deploys a new [Amazon Virtual Private Cloud (VPC)](https://github.com/webiny/webiny-js/blob/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi/prod/vpc.ts#L3) and that the single AWS Lambda function is [deployed into it](https://github.com/webiny/webiny-js/blob/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi/prod/graphql.ts#L87). Down the line, doing this for cloud infrastructure resources can improve our GraphQL API's overall security posture.

Note that, by default, the cloud infrastructure code in the [`prod`](https://github.com/webiny/webiny-js/tree/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi/prod) folder will only be used when deploying into the `prod` (production) environment. If you maybe wish to deploy the same into another environment, for example `staging`, you can set this in the [`pulumi/index.ts`](https://github.com/webiny/webiny-js/blob/cli-scaffold-react-app/packages/cli-plugin-scaffold-graphql-api/template/pulumi/index.ts#L8) entrypoint file.

:::info
Learn more about Pulumi, the default infrastructure-as-code (IaC) framework Webiny relies on, in the [Infrastructure as code with Pulumi](/docs/key-topics/deployment/iac-with-pulumi) key topic.
:::

### Extending the GraphQL API

The new GraphQL API can be extended in two ways.

A more manual approach would be to create and register new [`GraphQLSchemaPlugin`](https://github.com/webiny/webiny-js/blob/v5.11.0/packages/handler-graphql/src/plugins/GraphQLSchemaPlugin.ts#L10) plugins, via which you define how you want to extend the GraphQL schema and all of the resolver functions. To learn more, take a look at the the [Extend GraphQL API](/docs/how-to-guides/extend-graphql-api) guide.

On the other hand, a much faster way of extending the GraphQL API would be to use the [Extend GraphQL API](/docs/how-to-guides/webiny-cli/scaffolding/extend-graphql-api) scaffold, which not only creates all of the boilerplate code, but also a set of essential GraphQL query and mutations, sets up the database connection, generates sample tests, and more.

### First Deploy

Once you've completed the scaffold's wizard and the files have been generated, in order to actually access the GraphQL API, you need to deploy it. This can be done as usual via the [`webiny deploy`](/docs/how-to-guides/deployment/deploy-your-project) command, or, even easier, if you're about to jump straight into coding, by running the [`webiny watch`](/docs/how-to-guides/webiny-cli/use-watch-command) command. This command will not only deploy the changes, but also start a new watch session, which will automatically redeploy further application code changes, as you perform them. More on this below.

### Development Using the Watch Command

The most straightforward way to continue developing on top of the generated code would be via the [`webiny watch`](/docs/how-to-guides/webiny-cli/use-watch-command) command.

In order to get started, from your project root, simply run the following command:

```
yarn webiny watch {graphql-api-path} --env {env}
```

With the new watch session initialized, every change you make in the code will automatically trigger a re-deploy of the code, enabling you to see the changes in the cloud almost immediately as you make them (every redeployment takes 2-4 seconds to complete).

And although developers often choose this approach when developing smaller features or proof of concepts, for anything larger in scope, we recommend the new code to be tested via one or more different types of tests.

:::tip
To learn more about how to write different types of tests, we recommend you check out the [Writing and Running Tests](/docs/how-to-guides/webiny-cli/scaffolding/extend-graphql-api#writing-and-running-tests) section in the [Extend GraphQL API](/docs/how-to-guides/webiny-cli/scaffolding/extend-graphql-api) guide.
:::

## FAQ

#### How does security (authentication and authorization) work?

Please note that, by default, the authentication and authorization logic isn't included in the generated code. In other words, all of the generated GraphQL query and mutation operations can be performed by anonymous (not logged-in) users, which is in most cases not the desired behaviour.

Luckily, with a couple of built-in utilities, this can be relatively easily added. Please check out the [existing tutorials](/docs/tutorials/extend-admin-area/security/introduction) to learn how to implement these on your own.

#### Do I need to deploy the created GraphQL API in order to continue development?

Yes, every change that you make needs to be deployed into the cloud, in order to actually see it in action. At the moment, the local-development option isn't supported.
