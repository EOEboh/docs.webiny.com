---
id: create-a-webiny-headless-cms-custom-field-plugin
title: Create a Webiny Headless CMS custom field plugin
sidebar_label: Custom Field Plugin
keywords: ["webiny", "project", "install", "setup", "create"]
description: Create a Webiny Headless CMS custom field plugin.
---

import CenteredImage from "@components/CenteredImage";
import fieldDefinition from "./assets/field-definition.png";
import fieldRendered from "./assets/field-renderer.png";
import encryptedText from "./assets/encrypted-text.gif";

:::tip What you'll learn
* how to create a new content model field plugin
* how a plugin stores and retrieves data
:::

:::info
The complete code of this tutorial can also be found in our [GitHub examples repository](https://github.com/webiny/webiny-examples/).
:::

## Overview

Webiny offers a predefined set of content model fields in Headless CMS. Along with this, you can also create your custom Headless CMS fields.
In this tutorial, we will learn the anatomy of CMS fields and, as an example, will create a custom field plugin to store encrypted data in the database and decrypt it while retrieving the data.

## Plugins
Plugins are a vital part of Webiny, and the majority of Webiny's functionality lives in plugins. You can learn more about plugins [here](/docs/key-topics/plugins).

We will create our custom field with the help of plugins. Plugins will construct every part of the custom field i.e. we will create a plugin to list our new field in the field menu, another plugin to render the field, another one to store and retrieve data.

Webiny has five plugins types to create a custom CMS field.
Out of these, three are mandatory, and two are optional.
Let's briefly discuss these plugins types in this section, and in the further sections, we will see them in action.

1. **CmsEditorFieldTypePlugin** - It is used to define the field definition and is responsible for showing the field in the field menu on UI.

2. **CmsEditorFieldRendererPlugin** - It is responsible for the rendering part of the field, i.e. how the field will be rendered on create/update entry form is defined using the CmsEditorFieldRendererPlugin type.

3. **CmsModelFieldToGraphQLPlugin** - This plugin type is used to define the GraphQL part of the field.  

   These three mentioned plugins types are mandatory to create a custom field, and the next two are optional.

4. **CmsModelFieldToStoragePlugin** - These plugin types handle the storage transformations, i.e. you can modify the data before storing it in storage and also manipulate it while retrieving it.  
In this tutorial, as mentioned, we will store the encrypted data, and while retrieving, we will decrypt it. For these transformations, we will use this plugin type further in our tutorial.

5. **CmsModelFieldToElasticSearchPlugin** - Plugins of this type define transformations to run on a field with Elasticsearch interaction i.e. you can execute the transformations while storing the data and retrieving it from Elasticsearch.

Now, let's start building our custom field and see these plugins in action.
We will name the new custom field as `Secret Text`, as we are storing the encrypted text in the database.

### Field Type Plugin

We will start with creating field type plugin (`CmsEditorFieldTypePlugin`) to define the field's definition and to show it on the field menu on UI.

1. Create `fields/secretText` directory in `apps/admin/code/src/plugins/headlessCMS`.
2. Create a file `secretTextFieldPlugin.tsx` in newly created directory.

```tsx title="apps/admin/code/src/plugins/headlessCMS/fields/secretText/secretTextFieldPlugin.tsx"
import React from "react";
import { CmsEditorFieldTypePlugin } from "@webiny/app-headless-cms/types";

const TextIcon: React.FunctionComponent = () => (<i>icon</i>);

export default(): CmsEditorFieldTypePlugin => ({
    type: "cms-editor-field-type",
    name: "cms-editor-field-type-secret-text",
    field: {
        type: "secret-text",
        label: "Secret Text",
        description: "The encrypted text will be stored in the database.",
        icon: <TextIcon />,
        allowMultipleValues: false,
        allowPredefinedValues: false,
        multipleValuesLabel: "Use as list of text",
        createField() {
            return {
                type: "secret-text",
                validation: [],
                renderer: {
                    name: ""
                }
            };
        }
    }
});
```

3. Import this new plugin in `apps/admin/code/src/plugins/headlessCms.ts`.

```ts title="apps/admin/code/src/plugins/headlessCms.ts" {5,13}
(...)
import richTextEditor from "./headlessCMS/richTextEditor";

// Import the `secretTextFieldPlugin` plugin
import secretTextFieldPlugin from "./headlessCMS/fields/secretText/secretTextFieldPlugin"

export default [
    headlessCmsPlugins(),
    richTextEditor,
    // Rest of the plugins
    (...)
    objectFieldRenderer,
    secretTextFieldPlugin()
];
```

4. Run the `watch` command to start a new watch session on `apps/admin` application code.
```
yarn webiny watch apps/admin --env dev
```  
This command will build our application and will serve the admin app locally. It will also detect all changes in `apps/admin` and live rebuild the application.
You can learn more on `watch` command [here](/docs/how-to-guides/use-watch-command/).

As a result, our new field should be shown in field menu:
<CenteredImage src={fieldDefinition} alt="Field Definition" />

### Field Renderer Plugin
As a next step, we will define the renderer for the `secret text` field.
It will define how this field will be rendered on create/update entry form.  
We will create a field renderer plugin (`CmsEditorFieldRendererPlugin`) for the `secret text` field.

1. Create a file `secretTextFieldRendererPlugin.tsx` in `apps/admin/code/src/plugins/headlessCMS/fields/secretText` directory.

```tsx title="apps/admin/code/src/plugins/headlessCMS/fields/secretText/secretTextFieldRendererPlugin.tsx"
import React from "react";
import { CmsEditorFieldRendererPlugin } from "@webiny/app-headless-cms/types";
import { Input } from "@webiny/ui/Input";

export default(): CmsEditorFieldRendererPlugin => ({
    type: "cms-editor-field-renderer",
    name: "cms-editor-field-renderer-secret-text",
    renderer: {
        rendererName: "secret-text",
        name: `Secret Text`,
        description: `Enter the text to encrypt`,
        canUse({ field }) {
            return field.type === "secret-text";
        },
        render({ field, getBind }) {
            const Bind = getBind();

            return (
                <Bind>
                    {bind => (
                        <Input
                            {...bind}
                            label={field.label}
                            placeholder={field.placeholderText}
                            description={field.helpText}
                        />
                    )}
                </Bind>
            );
        }
    }
});
```

3. Import this new plugin in `apps/admin/code/src/plugins/headlessCms.ts`.

```ts title="apps/admin/code/src/plugins/headlessCms.ts" {5,14}
(...)
import richTextEditor from "./headlessCMS/richTextEditor";

// Import the `secretTextFieldRendererPlugin` plugin
import secretTextFieldRendererPlugin from "./headlessCMS/fields/secretText/secretTextFieldRendererPlugin"

export default [
    headlessCmsPlugins(),
    richTextEditor,
    // Rest of the plugins
    (...)
    objectFieldRenderer,
    secretTextFieldPlugin(),
    secretTextFieldRendererPlugin()
];
```

4. As the watch command is already running on `apps/admin`, we should see these changes immediately.
Drag and drop the `secret text` field to create a model and navigate to the `PREVIEW` tab; you should see an input field here:
<CenteredImage src={fieldRendered} alt="Field Rendered" />

Cool, so far, we are done with the UI part of the custom field. In the next step, we will handle the GraphQL part by creating a Field to GraphQL plugin (`CmsModelFieldToGraphQLPlugin`) for the `secret text` field.

### Field To GraphQL Plugin

1. Create `fields/secretText` directory in `api/code/headlessCMS/src`.
2. Create a file `secretTextFieldPlugin.ts` in newly created directory.
```ts title="api/code/headlessCMS/src/fields/secretText/secretTextFieldPlugin.ts"
import { CmsModelFieldToGraphQLPlugin } from "@webiny/api-headless-cms/types";

const createListFilters = ({ field }) => {
    return `
        ${field.fieldId}: String
        ${field.fieldId}_not: String
        ${field.fieldId}_in: [String]
        ${field.fieldId}_not_in: [String]
        ${field.fieldId}_contains: String
        ${field.fieldId}_not_contains: String
    `;
};

const plugin: CmsModelFieldToGraphQLPlugin = {
    name: "cms-model-field-to-graphql-secret-text",
    type: "cms-model-field-to-graphql",
    fieldType: "secret-text",
    isSortable: true,
    isSearchable: true,
    read: {
        createTypeField({ field }) {
            return `${field.fieldId}: String`;
        },
        createGetFilters({ field }) {
            return `${field.fieldId}: String`;
        },
        createListFilters
    },
    manage: {
        createListFilters,
        createTypeField({ field }) {
            return `${field.fieldId}: String`;
        },
        createInputField({ field }) {
            return field.fieldId + ": String";
        }
    }
};

export default plugin;
```
3. Import this new plugin in `api/code/headlessCMS/src/index.ts`.

```ts title="api/code/headlessCMS/src/index.ts" {5,12}
(...)
import scaffoldsPlugins from "./plugins/scaffolds";

// Import the `secretTextFieldPlugin` plugin
import secretTextFieldPlugin from "./fields/secretText/secretTextFieldPlugin"

export const handler = createHandler({
    plugins: [
    // Rest of the plugins
    (...)
    elasticsearchDataGzipCompression(),
    secretTextFieldPlugin
    (...)
});
```

4. Deploy the API changes, run the `watch` command to start a new watch session on `api/code/headlessCMS` application code.

```
yarn webiny watch api/code/headlessCMS --env dev
```  

Super, we are all set to use our new field in the CMS model. At this stage, our custom field will behave like a normal text. 
In this second part of this tutorial, we will encrypt the data before storing it in the database and decrypt it while retrieving it.

:::info
As mentioned earlier, the three plugins we have created so far are mandatory for creating a custom field. The plugins discussed in the next section are optional and can be used based on your requirements.
:::

## Storage transformations

Field to Storage Plugin (`CmsModelFieldToStoragePlugin`) is used to manipulate the data before storing it in storage and also to modify data while retrieving it.  
In our case, we will encrypt the data before storing it in the database and decrypt it while retrieving it. 

For encryption and decryption, we will use the [`cryptr`](https://www.npmjs.com/package/cryptr) package. 
So let's first add this package to our application.

1. Add `"cryptr": "^6.0.2"` in `api/code/headlessCMS/package.json` file.
2. Run `yarn` command in `api/code/headlessCMS` directory.

Now, let's proceed to create a field to storage plugin (`CmsModelFieldToStoragePlugin`) for the `secret text` field.

As a first step, we will encrypt data before storing it in the database.  
Create a file `secretTextFieldStoragePlugin.ts` in `api/code/headlessCMS/src/fields/secretText` directory.
```ts title="api/code/headlessCMS/src/fields/secretText/secretTextFieldStoragePlugin.ts"
import { CmsModelFieldToStoragePlugin } from "@webiny/api-headless-cms/types";
import cryptr from 'cryptr';

export default (): CmsModelFieldToStoragePlugin<String> => ({
    type: "cms-model-field-to-storage",
    name: "cms-model-field-to-storage-address",
    fieldType: "secret-text",
    async toStorage({ value }) {
        const encryptText = new cryptr('myTotalySecretKey').encrypt(value)
        return {
            value: encryptText
        };
    },
    async fromStorage({ value }) {
        return value.value
    }
});
```

As a next step, import this new plugin in `api/code/headlessCMS/src/index.ts`.

```ts title="api/code/headlessCMS/src/index.ts" {5,13}
(...)
import scaffoldsPlugins from "./plugins/scaffolds";

// Import the `secretTextFieldStoragePlugin` plugin
import secretTextFieldStoragePlugin from "./fields/secretText/secretTextFieldStoragePlugin"

export const handler = createHandler({
    plugins: [
    // Rest of the plugins
    (...)
    elasticsearchDataGzipCompression(),
    secretTextFieldPlugin,
    secretTextFieldStoragePlugin()
    (...)
});
```

Now, let's create a content entry with our new field.
<CenteredImage src={encryptedText} alt="Encrypted Text" />

As you create the entry, you will see your data is encrypted because, as per our current code, we encrypted our data while storing, but while retrieving, we are not decrypting it.

In the next step, let's decrypt the data while retrieving it.

1. Open the `api/code/headlessCMS/src/fields/secretText/secretTextFieldStoragePlugin.ts` file.
2. Update the `return` statement of `fromStorage` function with this:   
`return new cryptr('myTotalySecretKey').decrypt(value.value)`

```ts title="api/code/headlessCMS/src/fields/secretText/secretTextFieldStoragePlugin.ts" {5}
export default (): CmsModelFieldToStoragePlugin<String> => ({
    (...)
    
    async fromStorage({ value }) {
        return new cryptr('myTotalySecretKey').decrypt(value.value)
    }
    
    (...)
});
```
With this change, while retrieving data, it will be decrypted.

Congratulation, you have created your first custom field for Headless CMS!

## Extras!!

As discussed earlier, another optional plugin type is `CmsModelFieldToElasticsearchPlugin`.  
It is similar to the storage plugin but works with Elasticsearch, so you can do the transformations while storing the data in index and while retrieving it. [Here](https://github.com/webiny/webiny-js/blob/731966ba13e6d9c5c82828a89e0e9ef7d4a0a27d/packages/api-headless-cms-ddb-es/src/elasticsearch/indexing/numberIndexing.ts) is an example of Field to Elasticsearch Plugin.  

For primitive data types fields, `isSearchable: true` flag will do the work for you for indexing. But if you have a complex field or want to store your field in a certain special way, you can create a plugin of `CmsModelFieldToElasticsearchPlugin` type.