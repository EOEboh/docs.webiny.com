---
id: securing-your-application
title: Securing Your Application
sidebar_label: Securing Your Application
keywords: ["webiny", "application", "security"]
description: Learn how you can secure your applications.
---

import CenteredImage from "../../mdxComponents/centeredImage";
import securityGroupsSelection from "./securing-your-application/security-groups-selection.png";
import securityGroupsPermissions from "./securing-your-application/security-groups-permissions.png";
import addedSecurityPermissionsGroup from "./securing-your-application/added-security-permissions-group.png";
import unprotectedQuery from "./securing-your-application/unprotected-query.png";
import unprotectedMutation from "./securing-your-application/unprotected-mutation.png";
import graphqlAuthError from "./securing-your-application/query-auth-error.png";
import graphqlAuthSuccess from "./securing-your-application/query-auth-success.png";
import createTestUser from "./securing-your-application/create-test-user.png";
import newSecurityGroup from "./securing-your-application/new-security-group.png";
import contentLocaleSection from "./securing-your-application/content-locale-section.png";
import carManufacturersMenuItem from "./securing-your-application/car-manufacturers-menu-item.png";
import carManufacturersMenuItemHidden from "./securing-your-application/car-manufacturers-menu-item-hidden.png";
import routeNotAuthorized from "./securing-your-application/route-not-authorized.png";
import hidingNewButton from "./securing-your-application/hiding-new-button.png";
import hidingNewButtonHidden from "./securing-your-application/hiding-new-button-hidden.png";

:::tip What you'll learn
- what are security permissions and, on the code level, security permissions objects
- how to secure your application:
    - prevent unauthorized users from performing sensitive GraphQL API queries and mutations
    - prevent unauthorized users from seeing user-interface sections
:::

## Overview

In previous two sections, we've seen how we can quickly expand the GraphQL schema of the main GraphQL API, and also how we can add new modules in the **Admin Area** application. All with a couple of built-in scaffolding utilities.

In this tutorial, we expand our application by adding a layer of security around it. With it, we want to achieve the following:

1. prevent users from executing GraphQL API queries and mutations, if they don't have the necessary security permissions
2. prevent users from accessing modules we've added into the Admin Area application, if the user doesn't have the necessary security permissions

Note that in order to implement both behaviours, we are relying on **security permissions**, which is the first step of implementing a security layer for our application, and is the first topic we cover in this tutorial.

:::info
If you want to learn more about the main GraphQL API and how it works on the cloud infrastructure level, check out the [GraphQL Requests](/docs/key-topics/cloud-infrastructure/api/graphql-requests) page of the [Cloud Infrastructure - API](/docs/key-topics/cloud-infrastructure/api/introduction) key topics section.
:::

:::warning
Full Code example link
:::

## Security Permissions

> It all starts with security permissions.

On the code level, security permissions are just plain JavaScript objects, which allow us to perform identity [authorization](https://en.wikipedia.org/wiki/Authorization). In other words, these objects contain information that tells us which resources an identity (for example, a logged-in user) can access, and which it cannot.

"Can this user access this GraphQL query?", "Can this user edit this particular piece of data?", or "Can this user view this particular piece of user interface?, are just some of the questions that security permission objects can answer for us.

Except for the required `name` property, these objects don't follow any strict structure, which means that while we're developing our custom application, we can structure them in any way that fits our needs and business logic.

A simple security permission object might look something like the following:

```js
{
    // "name" property is required, the rest are optional.
    name: "my.custom.permission.object",
    canRead: true,
    canWrite: true,
    hasAccessToSomethingGreat: "maybe",
    canAccessUntil: "2025-06-01",
    somethingNested: {
        someRule: "here"
    }
}
```

## Assigning Security Permissions to Identities

Usually, security permissions are assigned to identities via security groups.

:::warning samo admin
NOTE OVO JE SAMO Admin. Vidi jos gdje staviti ovo, ne mora biti tu.
:::

Within Webiny's built-in Security application, every identity (for example, a logged in user) belongs to **exactly one** security group. But, note that a single security group can have multiple security permissions objects assigned to it, allowing or preventing access across multiple Webiny and your custom applications.

This can be seen while creating a new security group via the security groups module in the Admin Area, where you get to specify permissions for every installed Webiny application:

<CenteredImage alt="Only a Single Security Group Allowed" src={securityGroupsPermissions} />

Internally, making changes in one or more of these sections will result in one or more permission objects to be created. So, once we submit the form, all of the different permission objects that were created in the process, are sent to the GraphQL API and stored in the database (along with other general security group information - name, slug, and description).

:::warning identity-ji
dodati ovdje da kada kreiramo security group, onda radimo assign grupe na identity-je
:::

Ultimately, no matter if we're performing authorization on the API side or in the UI, via a couple of built-in Security application's utilities, we can retrieve identity's security group and all of the permissions it contains. With that data, we can then determine whether a user has access to a particular API resource or a section in the UI.

## Creating Custom Security Permissions

By adding a new permissions section in the security group form that we've seen above, we can allow system administrators to manually toggle access for our own custom features, for all identities that are linked with the particular security group.

Continuing with the car manufacturers example that we've used in previous tutorials, we could add a new **Car Manufacturers** section, and offer a couple of different options to the system administrator:

<CenteredImage alt="Added Security Permissions Group" src={addedSecurityPermissionsGroup} />

To achieve this, within the Webiny Admin Area React application, we need to register the following `admin-app-permissions-renderer` plugin:

```tsx title="packages/car-manufacturers/admin-app/src/permissions/index.tsx"
import React, { useCallback, useMemo } from "react";
import { i18n } from "@webiny/app/i18n";
import { AdminAppPermissionRendererPlugin } from "@webiny/app-admin/types";

// UI React Components - let's make it look nice:
import { Grid, Cell } from "@webiny/ui/Grid";
import { AccordionItem } from "@webiny/ui/Accordion";
import { ReactComponent as CarManufacturersIcon } from "../assets/directions_car-24px.svg";
import { PermissionInfo } from "@webiny/app-admin/components/Permissions";

// Components for working with forms:
import { Form } from "@webiny/form";
import { Select } from "@webiny/ui/Select";
import { Switch } from "@webiny/ui/Switch";

const t = i18n.ns("app-i18n/admin/plugins/permissionRenderer");
const PERMISSION_NAME = "car-manufacturers";

export default {
    type: "admin-app-permissions-renderer",
    name: "admin-app-permissions-renderer-car-manufacturers",
    render(props) {
        // `value` represents an array of all permission objects selected for the
        // security group we're currently editing. To apply changes to the `value`
        // array, we use the provided `onChange` callback.
        const { value, onChange } = props;

        // Callback that gets triggered whenever a form element has changed.
        // If needed, additional object manipulations can be performed too.
        const onFormChange = useCallback(
            data => {
                // Let's filter out the `car-manufacturer` permission object.
                // It's just easier to build a new one from scratch.
                const newPermissions = value.filter(item => item.name !== PERMISSION_NAME);

                // We only want the permissions object to end up in the `value` array if
                // we have a value in `rwd` or `specialFeature` properties.
                if (data.rwd || data.specialFeature) {
                    newPermissions.push(data);
                }

                // Finally, call the `onChange` callback to assign the permissions
                // object into the `value`.
                onChange(newPermissions);
            },
            [value]
        );

        // Set up default form data, which happens once the security group data
        // has been retrieved from the GraphQL API.
        const defaultFormData = useMemo(() => {
            return value.find(item => item.name === PERMISSION_NAME) || { name: PERMISSION_NAME };
        }, [value]);

        // We are using a couple of different React components to get the job done:
        // - for a nicer UI - AccordionItem, Grid, Cell, and PermissionInfo components
        // - for working with forms - Form, Bind, Select, and Switch components
        return (
            <AccordionItem
                icon={<CarManufacturersIcon />}
                title={t`Car Manufacturers`}
                description={t`Manage Car Manufacturer app access permissions.`}
            >
                <Form data={defaultFormData} onChange={onFormChange}>
                    {({ Bind }) => (
                        <Grid>
                            <Cell span={6}>
                                <PermissionInfo title={t`Access Level`} />
                            </Cell>
                            <Cell span={6}>
                                <Grid>
                                    <Cell span={12}>
                                        <Bind name={"rwd"}>
                                            <Select label={t`Access Level`}>
                                                <option value={"r"}>{t`Read`}</option>
                                                <option value={"rw"}>{t`Read, write`}</option>
                                                <option value={"rwd"}>{t`Read, write, delete`}</option>
                                            </Select>
                                        </Bind>
                                    </Cell>
                                    <Cell span={12}>
                                        <Bind name={"specialFeature"}>
                                            <Switch label={t`Has access to a special feature`} />
                                        </Bind>
                                    </Cell>
                                </Grid>
                            </Cell>
                        </Grid>
                    )}
                </Form>
            </AccordionItem>
        );
    }
} as AdminAppPermissionRendererPlugin;
```

Feel free to copy and paste the shown code into your project and use it as a starting point. And, after you do that, just make sure that the plugin is actually registered in `apps/admin/code/src/plugins/index.ts`, otherwise no change will appear in your browser.

If you've been following the previous two tutorials, then you can simply import it via the `packages/car-manufacturers/admin-app/src/index.ts` file:

```ts title="packages/car-manufacturers/admin-app/src/index.ts" {4,6}
import { Plugin } from "@webiny/plugins/types";
import menus from "./menus";
import routes from "./routes";
import permissions from "./permissions";

export default (): Plugin[] => [menus(), routes(), permissions];
```

By completing this step, we've added the new **Car Manufacturers** permissions section in the security group form. System administrators can now create new (or extend existing) security groups, and give access to our new Car Manufacturers module. For example, one security group can allow only reading car manufacturers data, while the other one may allow all three primary actions - read, write, and delete, and even allow access to the imaginary special feature.

Now that we have this new security permissions section, let's create the new **Car Manufacturers** security group, that enables full access to our new Car Manufacturers module. We'll need this security group in order to perform some manual testing down the road.

<CenteredImage alt="New Car Manufacturers Security Group" src={newSecurityGroup} />

Note that, at this point, nothing will actually happen for identities that have or don't have these newly added permissions in their security group. We still need to implement the actual authorization logic, both on the GraphQL API and Admin Area side, which we cover in the following sections.

### Content Locales

While creating the new Car Manufacturers security group, you might have noticed you immediately get to define access on a locale level.

<CenteredImage alt="asd" src={contentLocaleSection} />

:::warning
dovrsiti temu ovdje
:::

## Securing GraphQL API Resolvers

:::warning
yarn webiny watch negdje ubaciti
:::

At the moment, the `carManufacturers` queries and mutations, that we added to our main GraphQL API in the [API Package tutorial](/docs/tutorials/create-an-application/api-package), are publicly exposed.

For example, if were to perform a simple `listCarManufacturers` GraphQL query, we would receive a list of all car manufacturers:

<CenteredImage alt="Added Security Permissions Group" src={unprotectedQuery} />

Even more important, anybody can create new car manufacturers, with the `createCarManufacturer` GraphQL mutation:

<CenteredImage alt="Added Security Permissions Group" src={unprotectedMutation} />

In most cases, this is not the desirable behaviour, and you'll certainly want to have control over who can perform these GraphQL operations, and who cannot.

In order to secure these, we have to revisit the GraphQL resolver functions that were generated for us via the **GraphQL API package** scaffold.

:::info
Learn more about GraphQL resolver functions in the official GraphQL [documentation article](https://graphql.org/learn/execution/).
:::

All of the GraphQL resolver functions are located in the `packages/car-manufacturers/api/src/resolvers/` folder:

```bash title="packages/car-manufacturers/api/"
.
├── __tests__
├── dist
├── node_modules
└── src
    └── resolvers
        ├── createCarManufacturer.ts
        ├── deleteCarManufacturer.ts
        ├── getCarManufacturer.ts
        ├── index.ts
        ├── install.ts
        ├── isInstalled.ts
        ├── listCarManufacturers.ts
        ├── uninstall.ts
        └── updateCarManufacturer.ts
```

For purposes of this tutorial, we can open the simplest resolver, which is the `getCarManufacturer.ts`, and add the following lines of code:

```ts title="packages/car-manufacturers/api/src/resolvers/getCarManufacturer.ts" {2,17-37}
import { Response, NotFoundResponse } from "@webiny/handler-graphql";
import { NotAuthorizedResponse } from "@webiny/api-security";

import { utils } from "../utils";
import {
    ApplicationContext,
    GetCarManufacturerArgs,
    ResolverResponse,
    CarManufacturer
} from "../types";

const getCarManufacturer = async (
    _,
    args: GetCarManufacturerArgs,
    context: ApplicationContext
): Promise<ResolverResponse<CarManufacturer>> => {
    // We get the "car-manufacturers" permission from current identity (logged in user).
    const permission = await context.security.getPermission("car-manufacturers");
    if (!permission) {
        return new NotAuthorizedResponse();
    }

    // Note that the received permission object can also be `{ name: "*" }`. If so, that
    // means we are dealing with the super admin, who has unlimited access.
    let hasAccess = permission.name === "*";
    if (!hasAccess) {
        // If not super admin, let's check if we have the "r" in the `rwd` property.
        hasAccess =
            permission.name === "car-manufacturers" &&
            permission.rwd &&
            permission.rwd.includes("r");
    }

    // Finally, if current identity doesn't have access, we immediately exit.
    if (!hasAccess) {
        return new NotAuthorizedResponse();
    }

    const { db } = context;
    const { id } = args;

    const primaryKey = utils.createPk(context, id);

    const response = await db.read<CarManufacturer>({
        ...utils.db(context),
        query: {
            PK: primaryKey,
            SK: id
        },
        limit: 1
    });

    const [items] = response;
    const [item] = items;

    if (!item) {
        return new NotFoundResponse(`Car manufacturer with id "${id}" not found.`);
    }

    return new Response(item);
};

export default getCarManufacturer;
```

Now, to see this new piece of authorization logic in action, we can use a GraphQL client, for example the [GraphQL Playground](https://github.com/graphql/graphql-playground), point it to our GraphQL API's URL, and try executing the following query:

```graphql
{
  carManufacturers {
    # Replace the `id` with the value that exists in your system.
    getCarManufacturer (id: "6082ad846c073d0009ff0067") {
      data {
        id
        title
        isNice
      }
      error {
        message
        code
        data
      }
    }
  }
}
```

:::tip Misplaced GraphQL API URL?
Running the `yarn webiny info` command in your Webiny project folder will give you all of the relevant project URLs, including the URL of your GraphQL API.
:::

Without including the appropriate `Authorization` request header, we should receive the following error response:

<CenteredImage alt="GraphQL Authorization Error" src={graphqlAuthError} />

If you received the `SECURITY_NOT_AUTHORIZED` error, that means authorization was successful.

On the other hand, if a valid `Authorization` request header is included, or in other words, the current identity actually has access to the car manufacturers module, the data should correctly be returned.

To manually test that, we can simply create a new user via the Security / Users section, and either put it into the Full Access security group, or even better, into the newly created Car Manufacturers security group. Which is what the following screenshot is showing:

<CenteredImage alt="Create a Test User" src={createTestUser} />

Once we've created the user, we can log in into the Webiny Admin Area with it (using its username and password), and execute the same GraphQL query, this time using the built-in API Playground. We will use this client, simply because of the fact that, upon issuing GraphQL operations, it will automatically attach the correct `Authorization` request header for us.

:::warning
Learn more about the API Playground GraphQL client in the API Playground guide.
:::

So, as we can see in the following screenshot, the GraphQL query was successful, as we've successfully received the car manufacturer data in the response:

<CenteredImage alt="GraphQL Authorization Success" src={graphqlAuthSuccess} />

This means that the user we're currently logged in with has the appropriate security permissions, and that the newly added authorization code works as expected.

## Securing Admin Area Module

Let's wrap up this tutorial by adding authorization checks in the actual user interface. What we want to achieve is having a piece of UI hide if the currently logged-in user doesn't have access to it (doesn't have necessary security permissions).

For example, by completing the previous [Admin Area Package](/docs/tutorials/create-an-application/admin-area-package) tutorial, in our Webiny Admin Area, we should have the following item in the main menu:

<CenteredImage alt="Main Menu - Car Manufacturers Module" src={carManufacturersMenuItem} />

So, what we want to achieve here is the following:

- if the user is allowed to access the Car Manufacturers module, then make the menu item visible
- otherwise, if the user isn't allowed to access it, keep the menu item hidden

Note that when we say "has access", specifically in this case, we're going to check whether the user at least has the "read" permission.

The code for these menu items is located in the scaffolded `packages/car-manufacturers/admin-app/src/menus.tsx` file. So, in there, we can add the following code:

```tsx title="packages/car-manufacturers/admin-app/src/menus.tsx" {4,10-32}
import React from "react";
import { AdminMenuPlugin } from "@webiny/app-admin/types";
import { ReactComponent as Icon } from "./assets/directions_car-24px.svg";
import { useSecurity } from "@webiny/app-security";

export default (): AdminMenuPlugin => ({
    type: "admin-menu",
    name: "admin-menu-car-manufacturers",
    render({ Menu, Item }) {
        const { identity } = useSecurity();

        // We get the "car-manufacturers" permission from current identity (logged in user).
        const permission = identity.getPermission("car-manufacturers");
        if (!permission) {
            return null;
        }

        // Note that the received permission object can also be `{ name: "*" }`. If so, that
        // means we are dealing with the super admin, who has unlimited access.
        let hasAccess = permission.name === "*";
        if (!hasAccess) {
            // If not super admin, let's check if we have the "r" in the `rwd` property.
            hasAccess =
                permission.name === "car-manufacturers" &&
                permission.rwd &&
                permission.rwd.includes("r");
        }

        // Finally, if current identity doesn't have access, we immediately exit.
        if (!hasAccess) {
            return null;
        }

        return (
            <Menu name="menu-car-manufacturers" label={"Car Manufacturers"} icon={<Icon />}>
                <Item label={"Car Manufacturers"} path={"/car-manufacturers/"} />
            </Menu>
        );
    }
});
```

:::info
In order to conditionally render the Car Manufacturers menu items, we are using the [`useSecurity`](https://github.com/webiny/webiny-js/blob/next/packages/app-security/src/hooks/useSecurity.ts) React hook, imported from the [`@webiny/app-security`](https://github.com/webiny/webiny-js/tree/next/packages/app-security) package.
:::

As you may have noticed, we're using the exact same logic and code, that we previously used while trying to secure the `getCarManufacturer` GraphQL resolver function. The only thing that's different is the way we fetch the currently logged in identity's permission. Here, we are using the `useSecurity` React hook in order to first get the identity, and then, via the `getPermission` method, the `car-manufacturers` permission.

In order to manually test this, we can just log in with a user that doesn't belong to the Car Manufacturers security group. In that case, if everything was done correctly, we should not be able to see the Car Manufacturers menu item:

<CenteredImage alt="Main Menu - Car Manufacturers Module (Hidden)" src={carManufacturersMenuItemHidden} />

And while this is much better than what we had earlier, note that the actual route, to which the Car Manufacturers menu item linked, is still accessible. In other words, if a user tried to enter the `/car-manufacturers` URL path into the browser manually, the view would still be shown. This is simply because the route itself isn't secured.

To do that, let's jump to the `packages/car-manufacturers/admin-app/src/routes.tsx` file, in which we're going to wrap our all of our child React components with the `SecureRoute` component:

```tsx title="packages/car-manufacturers/admin-app/src/routes.tsx" {7,23-26,35}
import React, { Suspense, lazy } from "react";
import Helmet from "react-helmet";
import { Route } from "@webiny/react-router";
import { RoutePlugin } from "@webiny/app/types";
import { CircularProgress } from "@webiny/ui/Progress";
import { AdminLayout } from "@webiny/app-admin/components/AdminLayout";
import { SecureRoute } from "@webiny/app-security/components";

const Loader = ({ children, ...props }) => (
    <Suspense fallback={<CircularProgress />}>{React.cloneElement(children, props)}</Suspense>
);

const CarManufacturers = lazy(() => import("./views/CarManufacturers"));

export default (): RoutePlugin => ({
    type: "route",
    name: "route-admin-car-manufacturers",
    route: (
        <Route
            path={"/car-manufacturers"}
            exact
            render={() => (
                // In order to be able to access this route, the logged in user needs to
                // have the "car-manufacturers" permission. We don't inspect the extra
                // properties it may hold, we do that within rendered child components.
                <SecureRoute permission={"car-manufacturers"}>
                    <AdminLayout>
                        <Helmet>
                            <title>Car Manufacturers</title>
                        </Helmet>
                        <Loader>
                            <CarManufacturers />
                        </Loader>
                    </AdminLayout>
                </SecureRoute>
            )}
        />
    )
});
```

:::info
In order to conditionally render the `/car-manufacturers` route, we are using the [`SecureRoute`](https://github.com/webiny/webiny-js/blob/next/packages/app-security/src/components/SecureRoute.tsx) React component, imported from the [`@webiny/app-security`](https://github.com/webiny/webiny-js/tree/next/packages/app-security) package.
:::

So, with this newly added code in place, by entering the mentioned `/car-manufacturers` URL path into the browser, we'd receive the following:

<CenteredImage alt="Cannot Access Route - Not Authorized Message" src={routeNotAuthorized} />

And that's how you secure your routes. Note that we've only checking if the logged in user possesses the `car-manufacturers` permission. And although that's not a very authorization specific check, we can still consider is it as enough, since we can perform more specific checks within the rendered child React components.

As a final example, let's see how we can hide the New Car Manufacturer button, for users that don't posses the **write** permission.

<CenteredImage alt='Hiding the "New Car Manufacturer Button"' src={hidingNewButton} />

To do that, let's jump to the `CarManufacturersDataList` React component (`packages/car-manufacturers/admin-app/src/views/CarManufacturersDataList.tsx`), in which we're going to wrap the `ButtonSecondary` component with the `SecureView` component:

```tsx title="packages/car-manufacturers/admin-app/src/views/CarManufacturersDataList.tsx" {4,23-45,55-56}
import React, { useCallback, useEffect, useMemo } from "react";
(...)

import { SecureView } from "@webiny/app-security/components";

(...)

const CarManufacturersDataList: React.FunctionComponent<Props> = ({
    sortBy,
    setSortBy,
    limit,
    sorters
}) => {

    (...)

    return (
        <DataList
            loading={loading}
            title={t`CarManufacturers`}
            data={data}
            actions={
                {/* The SecureView component conditionally renders child components
                (depending on the result of the permissions check we provided) */}
                <SecureView permission={"car-manufacturers"}>
                    {({ permission }) => {
                        if (!permission) {
                            return null;
                        }

                        // Note that the received permission object can also be `{ name: "*" }`. If so, that
                        // means we are dealing with the super admin, who has unlimited access.
                        let hasAccess = permission.name === "*";
                        if (!hasAccess) {
                            // If not super admin, let's check if we have the "r" in the `rwd` property.
                            hasAccess =
                                permission.name === "car-manufacturers" &&
                                permission.rwd &&
                                permission.rwd.includes("r");
                        }

                        // Finally, if current identity doesn't have access, we immediately exit.
                        if (!hasAccess) {
                            return null;
                        }

                        return (
                            <ButtonSecondary
                                data-testid="new-carManufacturer-button"
                                onClick={() => history.push("/car-manufacturers/?new=true")}
                            >
                                <ButtonIcon icon={<AddIcon />} /> {t`New Car Manufacturer`}
                            </ButtonSecondary>
                        );
                    }}
                </SecureView>
            }
            modalOverlay={sortOverlay}
            modalOverlayAction={<DataListModalOverlayAction icon={<FilterIcon />} />}
        >
            {({ data }: DataListChildProps) => (
                <ScrollList data-testid="carManufacturer-data-list">
                    {(data || []).map(item => (
                        <ListItem key={item.id} selected={item.id === id}>
                            <ListItemText
                                onClick={() => history.push(`/carManufacturers?id=${item.id}`)}
                            >
                                {item.title}
                                {item.description && (
                                    <ListItemTextSecondary>
                                        {item.description}
                                    </ListItemTextSecondary>
                                )}
                            </ListItemText>

                            <ListItemMeta>
                                <ListActions>
                                    <DeleteIcon onClick={() => deleteCarManufacturerItem(item)} />
                                </ListActions>
                            </ListItemMeta>
                        </ListItem>
                    ))}
                </ScrollList>
            )}
        </DataList>
    );
};

export default CarManufacturersDataList;
```

:::info
In order to conditionally render the New Car Manufacturer button, we are using the [`SecureView`](https://github.com/webiny/webiny-js/blob/next/packages/app-security/src/components/SecureView.tsx) React component, imported from the [`@webiny/app-security`](https://github.com/webiny/webiny-js/tree/next/packages/app-security) package.
:::

And again, with this newly added code in place, we should no longer see the New Car Manufacturer button if the user doesn't posses the **write** permission.

<CenteredImage alt='Hiding the "New Car Manufacturer Button" (Hidden)' src={hidingNewButtonHidden} />

And that's how we can use the `SecureRoute` React component to conditionally render a React component.

With it, we've covered all of the possible ways you can perform authorization checks:

- the `useSecurity` React hook
- the `SecureRoute` React component
- the `SecureView` React component

These utilities will not only help you while extending the Webiny Admin Area, but also in any custom React application you might be working on. To learn more about how to use these in custom React application development, please check out the dedicated article (coming soon).

## FAQ

#### Can I assign multiple security groups to a single identity (user)?

No, you can't. Every identity can be part of exactly one security group. If you are in a situation where you need to assign multiple security groups to an identity, you'll need to create a new security group, that consist of all permissions that are assigned to the initial two.
