---
id: securing-your-application
title: Securing Your Application
sidebar_label: Securing Your Application
keywords: ["webiny", "application", "security"]
description: Learn how you can secure your applications.
---

import CenteredImage from "../../mdxComponents/centeredImage";
import securityGroupsSelection from "./securing-your-application/security-groups-selection.png";
import securityGroupsPermissions from "./securing-your-application/security-groups-permissions.png";
import addedSecurityPermissionsGroup from "./securing-your-application/added-security-permissions-group.png";
import unprotectedQuery from "./securing-your-application/unprotected-query.png";
import unprotectedMutation from "./securing-your-application/unprotected-mutation.png";
import graphqlAuthError from "./securing-your-application/query-auth-error.png";
import createTestUser from "./securing-your-application/create-test-user.png";
import newSecurityGroup from "./securing-your-application/new-security-group.png";
import contentLocaleSection from "./securing-your-application/content-locale-section.png";

:::tip What you'll learn
- what are security permissions and, on the code level, security permissions objects
- how to secure your application:
    - prevent unauthorized users from performing sensitive GraphQL API queries and mutations
    - prevent unauthorized users from seeing user-interface sections
:::

## Overview

In previous two sections, we've seen how we can quickly expand the GraphQL schema of the main GraphQL API, and also how we can add new modules in the **Admin Area** application. All with a couple of built-in scaffolding utilities.

In this tutorial, we expand our application by adding a layer of security around it. With it, we want to achieve the following:

1. prevent users from executing GraphQL API queries and mutations, if they don't have the necessary security permissions
2. prevent users from accessing modules we've added into the Admin Area application, if the user doesn't have the necessary security permissions

Note that in order to implement both behaviours, we are relying on **security permissions**, which is the first step of implementing a security layer for our application, and is the first topic we cover in this tutorial.

:::info
If you want to learn more about the main GraphQL API and how it works on the cloud infrastructure level, check out the [GraphQL Requests](/docs/key-topics/cloud-infrastructure/api/graphql-requests) page of the [Cloud Infrastructure - API](/docs/key-topics/cloud-infrastructure/api/introduction) key topics section.
:::

## Security Permissions

> It all starts with security permissions.

On the code level, security permissions are just plain JavaScript objects, which allow us to perform identity [authorization](https://en.wikipedia.org/wiki/Authorization). In other words, these objects contain information that tells us which resources an identity (for example, a logged-in user) can access, and which it cannot.

"Can this user access this GraphQL query?", "Can this user edit this particular piece of data?", or "Can this user view this particular piece of user interface?, are just some of the questions that security permission objects can answer for us.

Except for the required `name` property, these objects don't follow any strict structure, which means that while we're developing our custom application, we can structure them in any way that fits our needs and business logic.

A simple security permission object might look something like the following:

```js
{
    // "name" property is required, the rest are optional.
    name: "my.custom.permission.object",
    canRead: true,
    canWrite: true,
    hasAccessToSomethingGreat: "maybe",
    canAccessUntil: "2025-06-01",
    somethingNested: {
        someRule: "here"
    }
}
```

## Assigning Security Permissions to Identities

Usually, security permissions are assigned to identities via security groups.

:::info
NOTE OVO JE SAMO Admin. Vidi jos gdje staviti ovo, ne mora biti tu.
:::

Within Webiny's built-in Security application, every identity (for example, a logged in user) belongs to **exactly one** security group. But, note that a single security group can have multiple security permissions objects assigned to it, allowing or preventing access across multiple Webiny and your custom applications.

This can be seen while creating a new security group via the security groups module in the Admin Area, where you get to specify permissions for every installed Webiny application:

<CenteredImage alt="Only a Single Security Group Allowed" src={securityGroupsPermissions} />

Internally, making changes in one or more of these sections will result in one or more permission objects to be created. So, once we submit the form, all of the different permission objects that were created in the process, are sent to the GraphQL API and stored in the database (along with other general security group information - name, slug, and description).

Ultimately, no matter if we're performing authorization on the API side or in the UI, via a couple of built-in Security application's utilities, we can retrieve identity's security group and all of the permissions it contains. With that data, we can then determine whether a user has access to a particular API resource or a section in the UI.

## Creating Custom Security Permissions

By adding a new permissions section in the security group form that we've seen above, we can allow system administrators to manually toggle access for our own custom features, for all identities that are linked with the particular security group.

Continuing with the car manufacturers example that we've used in previous tutorials, we could add a new **Car Manufacturers** section, and offer a couple of different options to the system administrator:

<CenteredImage alt="Added Security Permissions Group" src={addedSecurityPermissionsGroup} />

To achieve this, within the Admin Area React application, we need to register a new `admin-app-permissions-renderer` plugin, like so:

```tsx title="packages/car-manufacturers/admin-app/src/permissions/index.tsx"
import React, { useCallback, useMemo } from "react";
import { i18n } from "@webiny/app/i18n";
import { AdminAppPermissionRendererPlugin } from "@webiny/app-admin/types";

// UI React Components - let's make it look nice:
import { Grid, Cell } from "@webiny/ui/Grid";
import { AccordionItem } from "@webiny/ui/Accordion";
import { ReactComponent as CarManufacturersIcon } from "../assets/directions_car-24px.svg";
import { PermissionInfo } from "@webiny/app-admin/components/Permissions";

// Components for working with forms:
import { Form } from "@webiny/form";
import { Select } from "@webiny/ui/Select";
import { Switch } from "@webiny/ui/Switch";

const t = i18n.ns("app-i18n/admin/plugins/permissionRenderer");
const PERMISSION_NAME = "car-manufacturers";

export default {
    type: "admin-app-permissions-renderer",
    name: "admin-app-permissions-renderer-car-manufacturers",
    render(props) {
        // `value` represents an array of all permission objects selected for the
        // security group we're currently editing. To apply changes to the `value`
        // array, we use the provided `onChange` callback.
        const { value, onChange } = props;

        // Callback that gets triggered whenever a form element has changed.
        // If needed, additional object manipulations can be performed too.
        const onFormChange = useCallback(
            data => {
                // Let's filter out the `car-manufacturer` permission object.
                // It's just easier to build a new one from scratch.
                const newPermissions = value.filter(item => item.name !== PERMISSION_NAME);

                // We only want the permissions object to end up in the `value` array if
                // we have a value in `rwd` or `specialFeature` properties.
                if (data.rwd || data.specialFeature) {
                    newPermissions.push(data);
                }

                // Finally, call the `onChange` callback to assign the permissions
                // object into the `value`.
                onChange(newPermissions);
            },
            [value]
        );

        // Set up default form data, which happens once the security group data
        // has been retrieved from the GraphQL API.
        const defaultFormData = useMemo(() => {
            return value.find(item => item.name === PERMISSION_NAME) || { name: PERMISSION_NAME };
        }, [value]);

        // We are using a couple of different React components to get the job done:
        // - for a nicer UI - AccordionItem, Grid, Cell, and PermissionInfo components
        // - for working with forms - Form, Bind, Select, and Switch components
        return (
            <AccordionItem
                icon={<CarManufacturersIcon />}
                title={t`Car Manufacturers`}
                description={t`Manage Car Manufacturer app access permissions.`}
            >
                <Form data={defaultFormData} onChange={onFormChange}>
                    {({ Bind }) => (
                        <Grid>
                            <Cell span={6}>
                                <PermissionInfo title={t`Access Level`} />
                            </Cell>
                            <Cell span={6}>
                                <Grid>
                                    <Cell span={12}>
                                        <Bind name={"rwd"}>
                                            <Select label={t`Access Level`}>
                                                <option value={"r"}>{t`Read`}</option>
                                                <option value={"rw"}>{t`Read, write`}</option>
                                                <option value={"rwd"}>{t`Read, write, delete`}</option>
                                            </Select>
                                        </Bind>
                                    </Cell>
                                    <Cell span={12}>
                                        <Bind name={"specialFeature"}>
                                            <Switch label={t`Has access to a special feature`} />
                                        </Bind>
                                    </Cell>
                                </Grid>
                            </Cell>
                        </Grid>
                    )}
                </Form>
            </AccordionItem>
        );
    }
} as AdminAppPermissionRendererPlugin;
```

Feel free to copy and paste the shown code into your project and use it as a starting point. After you do that, just make sure that the plugin is actually registered within the Admin Area React application (`apps/admin/code/src/plugins/index.ts`), otherwise no change will appear in your browser.

If you've been following the previous two tutorials, then you can simply import it via the `packages/car-manufacturers/admin-app/src/index.ts` file:

```ts title="packages/car-manufacturers/admin-app/src/index.ts" {4,6}
import { Plugin } from "@webiny/plugins/types";
import menus from "./menus";
import routes from "./routes";
import permissions from "./permissions";

export default (): Plugin[] => [menus(), routes(), permissions];
```

By completing this step, we've added the new **Car Manufacturers** permissions section in the security group form. In other words, system administrators can now create new or extend existing security groups, and give access to our new Car Manufacturers module. For example, one security group can allow only reading car manufacturers data, while the other one may allow all three primary actions - read, write, and delete, and even allow access to the imaginary special feature.

But note that, nothing will actually happen for identities that have or don't have these newly added permissions in their security group. We still need to implement the actual authorization logic, both on the GraphQL API and Admin Area side, which we cover in the following sections.

Before we continue, now that we have the new security permissions section, let's create the new **Car Manufacturers** security group, that enables full access to our new Car Manufacturers module. We'll need this security group in order to perform some testing down the road.

<CenteredImage alt="New Car Manufacturers Security Group" src={newSecurityGroup} />

### Content Locales

While creating the new Car Manufacturers security group, you might have noticed you immediately get to define access on a locale level.

<CenteredImage alt="asd" src={contentLocaleSection} />


## Securing GraphQL API Resolvers

:::tip
yarn webiny watch negdje ubaciti
:::

At the moment, the `CarManufacturer` queries and mutations, that we added to our main GraphQL API in the [API Package tutorial](/docs/tutorials/create-an-application/api-package), are publicly exposed.

For example, if were to perform a simple `listCarManufacturers` GraphQL query, we would receive a list of all car manufacturers:

<CenteredImage alt="Added Security Permissions Group" src={unprotectedQuery} />

Even worse, anybody can create new car manufacturers, with the `createCarManufacturer` GraphQL mutation, like so:

<CenteredImage alt="Added Security Permissions Group" src={unprotectedMutation} />

In most cases, this is not the desirable behaviour, and you'll certainly want to have control over who can perform these GraphQL operations, and who cannot.

In order to secure these, we have to revisit the GraphQL resolver functions that were generated for us via the **GraphQL API package** scaffold.

:::info
Learn more about GraphQL resolver functions in the official GraphQL [documentation article](https://graphql.org/learn/execution/).
:::

All of the GraphQL resolver functions are located in the `packages/car-manufacturers/api/src/resolvers/` folder:

```bash title="packages/car-manufacturers/api/"
.
├── __tests__
├── dist
├── node_modules
└── src
    └── resolvers
        ├── createCarManufacturer.ts
        ├── deleteCarManufacturer.ts
        ├── getCarManufacturer.ts
        ├── index.ts
        ├── install.ts
        ├── isInstalled.ts
        ├── listCarManufacturers.ts
        ├── uninstall.ts
        └── updateCarManufacturer.ts
```

As an example, we can open the simplest resolver, which is the `getCarManufacturer.ts`, and add the following lines of code:

```ts title="packages/car-manufacturers/api/src/resolvers/getCarManufacturer.ts" {17-34}
import { Response, NotFoundResponse } from "@webiny/handler-graphql";
import { NotAuthorizedResponse } from "@webiny/api-security";

import { utils } from "../utils";
import {
    ApplicationContext,
    GetCarManufacturerArgs,
    ResolverResponse,
    CarManufacturer
} from "../types";

const getCarManufacturer = async (
    _,
    args: GetCarManufacturerArgs,
    context: ApplicationContext
): Promise<ResolverResponse<CarManufacturer>> => {
    // We get the "car-manufacturers" permission from current identity (logged in user).
    const permission = await context.security.getPermission("car-manufacturers");
    if (!permission) {
        return new NotAuthorizedResponse();
    }

    // Note that the received permission object can also be `{ name: "*" }`. If so, that
    // means we are dealing with the super admin, who has unlimited access.
    let hasAccess = permission.name === "*";
    if (!hasAccess) {
        // If not super admin, let's check if we have the "r" in the `rwd` property.
        hasAccess = permission.name === "car-manufacturers" && permission.rwd.includes("r");
    }

    // Finally, if current identity doesn't have access, we immediately exit.
    if (!hasAccess) {
        return new NotAuthorizedResponse();
    }

    const { db } = context;
    const { id } = args;

    const primaryKey = utils.createPk(context, id);

    const response = await db.read<CarManufacturer>({
        ...utils.db(context),
        query: {
            PK: primaryKey,
            SK: id
        },
        limit: 1
    });

    const [items] = response;
    const [item] = items;

    if (!item) {
        return new NotFoundResponse(`CarManufacturer with id "${id}" not found.`);
    }

    return new Response(item);
};

export default getCarManufacturer;
```

To see this new piece of authorization logic in action, we can use a GraphQL client, for example the [GraphQL Playground](https://github.com/graphql/graphql-playground), point it to our GraphQL API's URL, and try executing the following query:

```graphql
{
  carManufacturers {
    # Replace the `id` with the value that exists in your system.
    getCarManufacturer (id: "6082ad846c073d0009ff0067") {
      data {
        id
        title
        isNice
      }
      error {
        message
        code
        data
      }
    }
  }
}
```

:::tip Misplaced GraphQL API URL?
Running the `yarn webiny info` command in your Webiny project folder will give you all of the relevant project URLs, including the URL of your GraphQL API.
:::

Without including the appropriate `Authorization` request header, we should receive the following error response:

<CenteredImage alt="GraphQL Authorization Error" src={graphqlAuthError} />

If you received the `SECURITY_NOT_AUTHORIZED` error, that means authorization was successful.

On the other hand, if a valid `Authorization` request header is included, or in other words, the current identity actually has access to the car manufacturers module, the data should correctly be returned.

To do that, we can simply create a new user via the Security / Users section, and either give it the Full Access security group, or the newly created

<CenteredImage alt="Create a Test User" src={createTestUser} />

## Securing Admin Area Module

Let's wrap up this tutorial by adding authorization checks in the actual user interface. What we want to achieve is having a piece of UI hide if the currently logged-in user doesn't have access to it (doesn't have necessary security permissions).


## FAQ

#### Can I assign multiple security groups to a single identity (user)?

No, you can't. Every identity can be part of exactly one security group. If you are in a situation where you need to assign multiple security groups to an identity, you'll need to create a new security group, that consist of all permissions that are assigned to the initial two.
