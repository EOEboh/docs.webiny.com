---
id: securing-your-application
title: Securing Your Application
sidebar_label: Securing Your Application
keywords: ["webiny", "application", "security"]
description: Learn how you can secure your applications.
---

import CenteredImage from "../../mdxComponents/centeredImage";
import securityGroupsSelection from "./securing-your-application/security-groups-selection.png";
import securityGroupsPermissions from "./securing-your-application/security-groups-permissions.png";
import addedSecurityPermissionsGroup from "./securing-your-application/added-security-permissions-group.png";
import unprotectedQuery from "./securing-your-application/unprotected-query.png";
import unprotectedMutation from "./securing-your-application/unprotected-mutation.png";

:::tip What you'll learn
- what are security permissions and, on the code level, security permissions objects
- how to secure your application:
    - prevent unauthorized users from performing sensitive GraphQL API queries and mutations
    - prevent unauthorized users from seeing user-interface sections
:::

## Overview

In previous two sections, we've seen how we can quickly expand the GraphQL schema of the main GraphQL API, and also how we can add new modules in the **Admin Area** application. All with a couple of built-in scaffolding utilities.

In this tutorial, we expand our application by adding a layer of security around it. With it, we want to achieve the following:

1. prevent users from executing GraphQL API queries and mutations, if they don't have the necessary security permissions
2. prevent users from accessing modules we've added into the Admin Area application, if the user doesn't have the necessary security permissions

Note that in order to implement both behaviours, we are relying on **security permissions**, which is the first step of implementing a security layer for our application, and is the first topic we cover in this tutorial.

:::info
If you want to learn more about the main GraphQL API and how it works on the cloud infrastructure level, check out the [GraphQL Requests](/docs/key-topics/cloud-infrastructure/api/graphql-requests) page of the [Cloud Infrastructure - API](/docs/key-topics/cloud-infrastructure/api/introduction) key topics section.
:::

## Security Permissions

> It all starts with security permissions.

On the code level, security permissions are just plain JavaScript objects, which allow us to perform identity [authorization](https://en.wikipedia.org/wiki/Authorization). In other words, these objects contain information that tells us which resources an identity (for example, a logged-in user) can access, and which it cannot.

"Can this user access this GraphQL query?", "Can this user edit this particular piece of data?", or "Can this user view this particular piece of user interface?, are just some of the questions that security permission objects can answer for us.

Except for the required `name` property, these objects don't follow any strict structure, which means that while we're developing our custom application, we can structure them in any way that fits our needs and business logic.

A simple security permission object might look something like the following:

```js
{
    // "name" property is required, the rest are optional.
    name: "my.custom.permission.object",
    canRead: true,
    canWrite: true,
    hasAccessToSomethingGreat: "maybe",
    canAccessUntil: "2025-06-01",
    somethingNested: {
        someRule: "here"
    }
}
```

## Assigning Security Permissions to Identities

Usually, security permissions are assigned to identities via security groups.

Within Webiny's built-in Security application, every identity (for example, a logged in user) belongs to **exactly one** security group. But, note that a single security group can have multiple security permissions objects assigned to it, allowing or preventing access across multiple Webiny and your custom applications.

This can be seen while creating a new security group via the security groups module in the Admin Area where you get to specify permissions for every installed Webiny application:

<CenteredImage alt="Only a Single Security Group Allowed" src={securityGroupsPermissions} />

Internally, making changes in one or more of these sections will result in one or more permission objects to be created. And, once we submit the form, all of the different permission objects that were created in the process, are sent to the GraphQL API and stored in the database (along with other general security group information - name, slug, and description).

Ultimately, no matter if we're performing authorization on the API side or in the UI, via a couple of built-in utilities, we can retrieve identity's security group and all of the permissions it contains. With that data, we can then determine whether a user has access to a particular API resource or a section in the UI.

## Defining Custom Security Permissions

By adding a new permissions section in the security group form that we've seen above, we can allow system administrators to manually toggle access for our own custom features, for all identities that are linked with the particular security group.

Continuing with the car manufacturers example that we've used in previous tutorials, we could add a new **Car Manufacturers** section, and offer a couple of different options to the system administrator:

<CenteredImage alt="Added Security Permissions Group" src={addedSecurityPermissionsGroup} />

To achieve this, within the Admin Area React application, we need to register a new `admin-app-permissions-renderer` plugin, like so:

```tsx title="packages/car-manufacturers/admin-app/src/permissions/index.tsx"
import React, { useCallback, useMemo } from "react";
import { i18n } from "@webiny/app/i18n";
import { AdminAppPermissionRendererPlugin } from "@webiny/app-admin/types";

// UI React Components - let's make it look nice:
import { Grid, Cell } from "@webiny/ui/Grid";
import { AccordionItem } from "@webiny/ui/Accordion";
import { ReactComponent as CarManufacturersIcon } from "../assets/directions_car-24px.svg";
import { PermissionInfo } from "@webiny/app-admin/components/Permissions";

// Components for working with forms:
import { Form } from "@webiny/form";
import { Select } from "@webiny/ui/Select";
import { Switch } from "@webiny/ui/Switch";

const t = i18n.ns("app-i18n/admin/plugins/permissionRenderer");
const PERMISSION_NAME = "car-manufacturers";

export default {
    type: "admin-app-permissions-renderer",
    name: "admin-app-permissions-renderer-car-manufacturers",
    render(props) {
        // `value` represents an array of all permission objects selected for the
        // security group we're currently editing. To apply changes to the `value`
        // array, we use the provided `onChange` callback.
        const { value, onChange } = props;

        // Callback that gets triggered whenever a form element has changed.
        // If needed, additional object manipulations can be performed too.
        const onFormChange = useCallback(
            data => {
                // Let's filter out the `car-manufacturer` permission object.
                // It's just easier to build a new one from scratch.
                const newPermissions = value.filter(item => item.name !== PERMISSION_NAME);

                // We only want the permissions object to end up in the `value` array if
                // we have a value in `rwd` or `specialFeature` properties.
                if (data.rwd || data.specialFeature) {
                    newPermissions.push(data);
                }

                // Finally, call the `onChange` callback to assign the permissions
                // object into the `value`.
                onChange(newPermissions);
            },
            [value]
        );

        // Set up default form data, which happens once the security group data
        // has been retrieved from the GraphQL API.
        const defaultFormData = useMemo(() => {
            return value.find(item => item.name === PERMISSION_NAME) || { name: PERMISSION_NAME };
        }, [value]);

        // We are using a couple of different React components to get the job done:
        // - for a nicer UI - AccordionItem, Grid, Cell, and PermissionInfo components
        // - for working with forms - Form, Bind, Select, and Switch components
        return (
            <AccordionItem
                icon={<CarManufacturersIcon />}
                title={t`Car Manufacturers`}
                description={t`Manage Car Manufacturer app access permissions.`}
            >
                <Form data={defaultFormData} onChange={onFormChange}>
                    {({ Bind }) => (
                        <Grid>
                            <Cell span={6}>
                                <PermissionInfo title={t`Access Level`} />
                            </Cell>
                            <Cell span={6}>
                                <Grid>
                                    <Cell span={12}>
                                        <Bind name={"rwd"}>
                                            <Select label={t`Access Level`}>
                                                <option value={"r"}>{t`Read`}</option>
                                                <option value={"rw"}>{t`Read, write`}</option>
                                                <option value={"rwd"}>{t`Read, write, delete`}</option>
                                            </Select>
                                        </Bind>
                                    </Cell>
                                    <Cell span={12}>
                                        <Bind name={"specialFeature"}>
                                            <Switch label={t`Has access to a special feature`} />
                                        </Bind>
                                    </Cell>
                                </Grid>
                            </Cell>
                        </Grid>
                    )}
                </Form>
            </AccordionItem>
        );
    }
} as AdminAppPermissionRendererPlugin;
```

Feel free to copy and paste the shown code into your project and use it as a starting point. After you do that, just make sure that the plugin is actually registered within the Admin Area React application (`apps/admin/code/src/plugins/index.ts`), otherwise no change will appear in your browser.

If you've been following the previous two tutorials, then you can simply import it via the `packages/car-manufacturers/admin-app/src/index.ts` file:

```ts title="packages/car-manufacturers/admin-app/src/index.ts" {4,6}
import { Plugin } from "@webiny/plugins/types";
import menus from "./menus";
import routes from "./routes";
import permissions from "./permissions";

export default (): Plugin[] => [menus(), routes(), permissions];
```

By completing this step, we added the ability for system administrators to define whether an identity, that belongs to currently viewed security group, can perform read, write, and delete actions on the car manufacturers data, and also whether it has access to an imaginary special feature.

But note that, nothing will actually happen for identities that have or don't have these permissions in their security group. We still need to implement the actual logic, both on the API and Admin Area side, which we cover in the following sections.

## Securing GraphQL API Resolvers

OVO DOLJE
```
yarn webiny ws run watch --folder packages/car-manufacturers
```

At the moment, the `CarManufacturer` queries and mutations, that we added to our main GraphQL API in the [API Package tutorial](/docs/tutorials/create-an-application/api-package), are publicly exposed.

For example, if were to perform a simple `listCarManufacturers` GraphQL query, we would receive a list of all car manufacturers:

<CenteredImage alt="Added Security Permissions Group" src={unprotectedQuery} />

Even worse, anybody can create new car manufacturers, with the `createCarManufacturer` GraphQL mutation, like so:

<CenteredImage alt="Added Security Permissions Group" src={unprotectedMutation} />

In most cases, this is not the desirable behaviour, and you'll certainly want to have control over who can perform these GraphQL operations, and who cannot.

In order to secure these, we have to revisit the GraphQL resolver functions that were generated for us via the **GraphQL API package** scaffold.

:::info
Learn more about GraphQL resolver functions in the official GraphQL [documentation article](https://graphql.org/learn/execution/).
:::

All of the GraphQL resolver functions are located in the `packages/car-manufacturers/api/src/resolvers/` folder:

```bash title="packages/car-manufacturers/api/"
.
├── __tests__
├── dist
├── node_modules
└── src
    └── resolvers
        ├── createCarManufacturer.ts
        ├── deleteCarManufacturer.ts
        ├── getCarManufacturer.ts
        ├── index.ts
        ├── install.ts
        ├── isInstalled.ts
        ├── listCarManufacturers.ts
        ├── uninstall.ts
        └── updateCarManufacturer.ts
```

As an example, we can open the simplest resolver, which is the `getCarManufacturer.ts`, and add the following lines of code:

```ts title="packages/car-manufacturers/api/src/resolvers/getCarManufacturer.ts"
import { Response, NotFoundResponse } from "@webiny/handler-graphql";
import { utils } from "../utils";
import { ApplicationContext, GetCarManufacturerArgs, ResolverResponse, CarManufacturer } from "../types";

const getCarManufacturer = async (
    _,
    args: GetCarManufacturerArgs,
    context: ApplicationContext
): Promise<ResolverResponse<CarManufacturer>> => {
    const { db } = context;
    const { id } = args;
    /**
     * Primary key is always constructed out of the id and a fixed CarManufacturer configuration.
     */
    const primaryKey = utils.createPk(context, id);
    /**
     * Fetch the CarManufacturer record from the DynamoDB.
     * Response is a tuple of records (always an array) and plain object containing some query and response information.
     */
    const response = await db.read<CarManufacturer>({
        ...utils.db(context),
        query: {
            PK: primaryKey,
            SK: id
        },
        limit: 1
    });
    const [items] = response;
    const [item] = items;
    /**
     * Fail with NotFoundResponse if no item.
     */
    if (!item) {
        return new NotFoundResponse(`CarManufacturer with id "${id}" not found.`);
    }

    return new Response(item);
};

export default getCarManufacturer;
```

## Securing Admin Area Module

Let's finish by adding authorization checks in the actual user interface.

## FAQ

#### Can I assign multiple security groups to a single identity (user)?

No, you can't. Every identity can be part of exactly one security group. If you are in a situation where you need to assign multiple security groups to an identity, you'll need to create a new security group, that consist of all permissions that are assigned to the initial two.
