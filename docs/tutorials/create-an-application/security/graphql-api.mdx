---
id: graphql-api
title: GraphQL API
sidebar_label: GraphQL API
keywords: ["application", "security", "graphql", "api"]
description: Learn how you can secure your GraphQL API.
---

import CenteredImage from "../../../mdxComponents/centeredImage";
import securityGroupsSelection from "./assets/security-groups-selection.png";
import securityGroupsPermissions from "./assets/security-groups-permissions.png";
import addedSecurityPermissionsGroup from "./assets/added-security-permissions-group.png";
import unprotectedQuery from "./assets/unprotected-query.png";
import unprotectedMutation from "./assets/unprotected-mutation.png";
import graphqlAuthError from "./assets/query-auth-error.png";
import graphqlAuthSuccess from "./assets/query-auth-success.png";
import createTestUser from "./assets/create-test-user.png";
import newSecurityGroup from "./assets/new-security-group.png";
import contentLocaleSection from "./assets/content-locale-section.png";
import carManufacturersMenuItem from "./assets/car-manufacturers-menu-item.png";
import carManufacturersMenuItemHidden from "./assets/car-manufacturers-menu-item-hidden.png";
import routeNotAuthorized from "./assets/route-not-authorized.png";
import hidingNewButton from "./assets/hiding-new-button.png";
import hidingNewButtonHidden from "./assets/hiding-new-button-hidden.png";

:::tip What you'll learn
- prevent unauthorized users from performing sensitive GraphQL API queries and mutations
:::

## Overview

:::info
The code that we will cover in this tutorial can also be found in our [GitHub examples repository](https://github.com/webiny/webiny-examples/tree/master/extend-admin-area/security/packages/car-manufacturers/api).
:::

At the moment, the `carManufacturers` queries and mutations, that we added to our main GraphQL API in the [API Package](/docs/tutorials/create-an-application/api-package) tutorial, are publicly exposed.

For example, if were to perform a simple `listCarManufacturers` GraphQL query, we would receive a list of all car manufacturers:

<CenteredImage alt="Added Security Permissions Group" src={unprotectedQuery} />

Even more important, anybody can create new car manufacturers, with the `createCarManufacturer` GraphQL mutation:

<CenteredImage alt="Added Security Permissions Group" src={unprotectedMutation} />

In most cases, this is not the desirable behaviour, and you'll certainly want to have control over who can perform these GraphQL operations, and who cannot.

## Securing GraphQL API Resolvers

In order to secure our GraphQL API, we have to revisit the GraphQL resolver functions that were generated for us via the **GraphQL API package** scaffold.

:::info
Learn more about GraphQL resolver functions in the official GraphQL [documentation article](https://graphql.org/learn/execution/).
:::

All of the GraphQL resolver functions are located in the `packages/car-manufacturers/api/src/resolvers/` folder:

```bash title="packages/car-manufacturers/api/"
.
├── __tests__
├── dist
├── node_modules
└── src
    └── resolvers
        ├── createCarManufacturer.ts
        ├── deleteCarManufacturer.ts
        ├── getCarManufacturer.ts
        ├── index.ts
        ├── install.ts
        ├── isInstalled.ts
        ├── listCarManufacturers.ts
        ├── uninstall.ts
        └── updateCarManufacturer.ts
```

For purposes of this tutorial, we can open the simplest resolver, which is the `getCarManufacturer.ts`, and add the following lines of code:

```ts title="packages/car-manufacturers/api/src/resolvers/getCarManufacturer.ts" {2,4-5,13,14,22-51}
import { Response, NotFoundResponse } from "@webiny/handler-graphql";
import { NotAuthorizedResponse } from "@webiny/api-security";

// We use this when specifying the return types of the getPermission function call (below).
import { FullAccessPermission } from "@webiny/api-security/types";

import { utils } from "../utils";
import {
    ApplicationContext,
    GetCarManufacturerArgs,
    ResolverResponse,
    CarManufacturer,
    // Creating types for security permissions makes our code less error-prone and more readable.
    CarManufacturersPermission
} from "../types";

const getCarManufacturer = async (
    _,
    args: GetCarManufacturerArgs,
    context: ApplicationContext
): Promise<ResolverResponse<CarManufacturer>> => {
    // First, check if the current identity can perform the "getCarManufacturer" query,
    // within the detected locale. An error will be thrown if access is not allowed.
    await context.i18nContent.checkI18NContentPermission();

    // Next, check if the current identity possesses the "car-manufacturers" permission.
    // Note that, if the identity has full access, "FullAccessPermission" permission
    // will be returned instead, which is equal to: { name: "*"}.
    const permission = await context.security.getPermission<
        CarManufacturersPermission | FullAccessPermission
        >("car-manufacturers");

    if (!permission) {
        return new NotAuthorizedResponse();
    }

    // Note that the received permission object can also be `{ name: "*" }`. If so, that
    // means we are dealing with the super admin, who has unlimited access.
    let hasAccess = permission.name === "*";
    if (!hasAccess) {
        // If not super admin, let's check if we have the "r" in the `rwd` property.
        hasAccess =
            permission.name === "car-manufacturers" &&
            permission.rwd &&
            permission.rwd.includes("r");
    }

    // Finally, if current identity doesn't have access, we immediately exit.
    if (!hasAccess) {
        return new NotAuthorizedResponse();
    }

    const { db } = context;
    const { id } = args;

    const primaryKey = utils.createPk(context, id);

    const response = await db.read<CarManufacturer>({
        ...utils.db(context),
        query: {
            PK: primaryKey,
            SK: id
        },
        limit: 1
    });

    const [items] = response;
    const [item] = items;

    if (!item) {
        return new NotFoundResponse(`CarManufacturer with id "${id}" not found.`);
    }

    return new Response(item);
};

export default getCarManufacturer;
```

:::tip
If you're curious about the `CarManufacturersPermission` type, check its definition in [packages/car-manufacturers/api/src/types.ts:173](https://github.com/webiny/webiny-examples/blob/master/extend-admin-area/security/packages/car-manufacturers/api/src/types.ts#L173).
:::

Now, to see this new piece of authorization logic in action, we can use a GraphQL client, for example the [GraphQL Playground](https://github.com/graphql/graphql-playground), point it to our GraphQL API's URL, and try executing the following query:

```graphql
{
  carManufacturers {
    # Replace the `id` with the value that exists in your system.
    getCarManufacturer (id: "6082ad846c073d0009ff0067") {
      data {
        id
        title
        isNice
      }
      error {
        message
        code
        data
      }
    }
  }
}
```

:::tip Misplaced GraphQL API URL?
Running the `yarn webiny info` command in your Webiny project folder will give you all of the relevant project URLs, including the URL of your GraphQL API.
:::

Without including the appropriate `Authorization` request header, we should receive the following error response:

<CenteredImage alt="GraphQL Authorization Error" src={graphqlAuthError} />

If you received the `SECURITY_NOT_AUTHORIZED` error, that means authorization was successful.

On the other hand, if a valid `Authorization` request header is included, or in other words, the current identity actually has access to the Car Manufacturers module, the data should correctly be returned.

To manually test that, we can simply create a new user via the Webiny Security application, and either place it into the default Full Access security group, or even better, into the newly created Car Manufacturers security group. Which is what the following screenshot is showing:

<CenteredImage alt="Create a Test User" src={createTestUser} />

Once we've created the user, we can log in into the Webiny Admin Area with it (using its username and password), and execute the same GraphQL query, this time using the built-in API Playground. We will use this client simply because of the fact that, upon issuing GraphQL operations, it will automatically attach the correct `Authorization` request header for us. In other words, it will perform GraphQL operations as the currently logged in user.

:::warning
Learn more about the API Playground GraphQL client in the API Playground guide.
:::

So, as we can see in the following screenshot, the GraphQL query was successful, as we've successfully received the car manufacturer data in the response:

<CenteredImage alt="GraphQL Authorization Success" src={graphqlAuthSuccess} />

This means that the user we're currently logged in with has the appropriate security permissions, and that the newly added authorization code works as expected.

## Final Notes

Before we wrap this up, note that this is just a single resolver we secured, and that you should implement the same logic into [others](https://github.com/webiny/webiny-examples/tree/master/extend-admin-area/security/packages/car-manufacturers/api/src/resolvers) as well. Also, in case you start seeing yourself copying some of the authorization related code, it's certainly recommended that you extract it into one or more separate utility functions. This way we're not repeating our selves ([DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) and our code will be more maintainable and less error-prone.

## FAQ

#### Can I assign multiple security groups to a single identity (user)?

No, you can't. Every identity can be part of exactly one security group. If you are in a situation where you need to assign multiple security groups to an identity, you'll need to create a new security group, that consist of all permissions that are assigned to the initial two.
