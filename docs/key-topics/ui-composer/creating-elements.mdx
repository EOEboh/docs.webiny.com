---
id: creating-elements
title: Creating Elements
sidebar_label: Creating Elements
keywords: ["webiny", "ui", "composer", "react", "element"]
description: Learn how to create custom elements to use with UI Composer
---

import CenteredImage from "@components/CenteredImage";
import firstButton from "./assets/firstButton.png";
import secondButton from "./assets/secondButton.png";
import devTools from "./assets/devTools.png";

:::tip What you'll learn

- how to create elements
- how to implement various renderers

:::

## Overview

Elements are the basic building blocks of your UI, and allow you to have a nice, developer-friendly SDK for your projects. In this article we look at how to create a simple element, how to make it pluginable, and how to support various renderers.

## Creating a Basic Element

Let's create a `HeadingElement` element, to render simple heading tags. It will accept `size` and `text` parameters.

```ts title="Defining an Element Class"
import { UIElement, UIElementConfig } from "@webiny/ui-composer/UIElement";

interface HeadingElementConfig extends UIElementConfig {
  text: string;
  size: number;
}

class HeadingElement extends UIElement<HeadingElementConfig> {
  private _heading = {
    1: "h1",
    2: "h2"
  };

  getSize() {
    return this.config.size;
  }

  getText() {
    return this.config.text;
  }

  render(props?: any): React.ReactNode {
    const Component = this._heading[this.getSize()];
    return <Component>{this.getText()}</Component>;
  }
}
```

:::tip
You can structure the class however you like. This is not React, these are plain classes. The only important thing is that it extends the `UIElement` base class.
:::

When instantiating an element, it always needs to have a unique ID. That's how other developers will be able to reference that particular element from their plugins.

```ts title="Instantiating an Element Class"
new HeadingElement("heading", { size: 2, text: "MyHeading" });
```

When you add this element to a view (as described in the [Building Views](/docs/key-topics/ui-composer/building-views) article), it will render an `<h2>` element. Currently, this element only supports `h1` and `h2`. We'll get to that later.

## Making Element Extendable

To make your custom elements extendable via plugins, we need to call the plugins from the class constructor. And to expose a meaningful public API, we need to add some setters so that other developers can set new configuration.

```ts title="Apply Element Plugins" {7-22}
class HeadingElement extends UIElement<HeadingElementConfig> {
  private _heading = {
    1: "h1",
    2: "h2"
  };

  constructor(id: string, config: HeadingElementConfig) {
    super(id, config);

    // Apply plugins of type `UIElementPlugin` registered for this particular class
    this.applyPlugins(HeadingElement);
  }

  // Add size setter
  setSize(size: number) {
    this.config.size = size;
  }

  // Add text setter
  setText(text: string) {
    this.config.text = text;
  }

  getSize() {
    return this.config.size;
  }

  getText() {
    return this.config.text;
  }

  render(props?: any): React.ReactNode {
    const Component = this._heading[this.getSize()];
    return <Component>{this.getText()}</Component>;
  }
}
```

Now anyone can hook into your element:

```ts title="Hooking Into Any Element"
import { UIElementPlugin } from "@webiny/ui-composer/UIElement";

new UIElementPlugin<HeadingElement>(HeadingElement, element => {
  // This will be called for every HeadingElement

  // You can conditionally make changes to the element instance
  if (element.id === "heading") {
    element.setSize(1);
  }
});
```
